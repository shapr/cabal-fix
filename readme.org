* cabal-fix

[[https://hackage.haskell.org/package/cabal-fixes][https://img.shields.io/hackage/v/cabal-fix.svg]]
[[https://github.com/tonyday567/cabal-fixes/actions?query=workflow%3Ahaskell-ci][https://github.com/tonyday567/cabal-fix/workflows/haskell-ci/badge.svg]]

~cabal-fix~ helps fix warts in your cabal files.

** ToDo cabal fixes

- [ ] check individual project diffs
  - [ ] cabal build & cabal check
  - [ ] commit
- [ ] eulerproject cabal
- [X] insert LICENSE
- [X] add copyright
  - [X] based on years
- [X] revert category

- [X] test the config sucker
- [X] narrow method for build-deps
- [X] bugz
  - [X] description always has an extra line
  - [X] build-deps not working

- [X] overwrites
  - [X] policy
- [X] fixCommas
  - [X] commastyle
- [X] sortFields
- [X] sortFieldLines
- [X] removeBlankFields
- [X] fixBuildDeps

* cabal file listing

#+begin_src haskell :results output
:r
:set prompt "> "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
putStrLn "ok"
import Data.Char
import CabalFix
import System.Directory
import Control.Monad
import Data.List qualified as List
import Data.Function
import Box
import Data.Bifunctor
import Data.ByteString (ByteString)
import Data.ByteString qualified as B
import Data.ByteString.Char8 qualified as C
import Data.TreeDiff
import Text.Pretty.Simple
import Data.Algorithm.Diff
import MarkupParse.Patch
import System.FilePath
#+end_src

#+RESULTS:
#+begin_example
Build profile: -w ghc-9.6.2 -O1
In order, the following will be built (use -v for more details):
 - cabal-fix-0.0.0.1 (lib) (configuration changed)
Configuring library for cabal-fix-0.0.0.1..
Preprocessing library for cabal-fix-0.0.0.1..
GHCi, version 9.6.2: https://www.haskell.org/ghc/  :? for help
[1 of 1] Compiling CabalFix         ( src/CabalFix.hs, interpreted )
Ok, one module loaded.
ghci> Ok, one module loaded.
ok
#+end_example

* Retrieve test cabals

#+begin_src haskell :results output
cs <- getTestCabals
cs' = Map.fromList cs
bs = fromMaybe (error "bad lookup") $ Map.lookup "numhask.cabal" cs'
#+end_src

#+RESULTS:

rerender and save as a file

#+begin_src haskell :results output
fst <$> cs
#+end_src

#+RESULTS:
: ["tonyday567.cabal","research-hackage.cabal","anal.cabal","numhask-array.cabal","chart-svg.cabal","cabal-fix.cabal","numhask-space.cabal","mealy.cabal","formatn.cabal","prettychart.cabal","dotparse.cabal","perf.cabal","numhask.cabal","ephemeral.cabal","box-socket.cabal","iqfeed.cabal","box.cabal","code.cabal","foo.cabal","web-rep.cabal","poker-fold.cabal"]

#+begin_src haskell :results output
void $ mapM (\(fp,bs) -> BS.writeFile ("/Users/tonyday/haskell/cabal-fix/test/rendered/" <> fp) bs) (second (rerenderCabal (defaultRenderConfig)) <$> cs)
#+end_src

#+RESULTS:

** rerenderCabal idempotence

#+begin_src haskell :results output
xs <- getTestCabals
#+end_src

#+RESULTS:

#+begin_src haskell :results output
xs' = (second (rerenderCabal (defaultRenderConfig)) <$> xs)
xs' == (second (rerenderCabal (defaultRenderConfig)) <$> xs')
#+end_src

#+RESULTS:
: True

* Diff

#+begin_src haskell :results output
import Data.Algorithm.DiffOutput
prettyDiffs $ diffToLineRanges $ getGroupedDiff (C.unpack <$> C.dropWhile isSpace <$> (C.lines bs)) (C.unpack <$> C.dropWhile isSpace <$> (C.lines $ rerenderCabal bs))

#+end_src

#+RESULTS:
: 1a2
: 21d21
: <
: 35c35,36
: < import: lang
: ---
: import:
: lang
: 46a48

* all the cabals

#+begin_src haskell :results output
allCabalProjects "/Users/tonyday/haskell"
#+end_src

#+RESULTS:
: ["numhask","eulerproject","mealy","box","formatn","prettychart","cabal-fix","code","poker-fold","numhask-space","iqfeed","box-socket","numhask-array","tonyday567","foo","web-rep","baz","dotparse","perf","anal","research-hackage","chart-svg","ephemeral"]

#+begin_src haskell :results output
cs <- allCabals "/Users/tonyday/haskell"
:t cs
#+end_src

#+RESULTS:
: cs :: [(String, ByteString)]

** write all the cabals

#+begin_src haskell :results output
cs <- getCabals "/Users/tonyday/haskell/cabal-fix/test/rendered/"
ns = takeWhile (/='.') . fst <$> cs
ns
#+end_src

#+RESULTS:
: ["tonyday567","research-hackage","anal","numhask-array","chart-svg","cabal-fix","numhask-space","mealy","formatn","prettychart","dotparse","perf","numhask","ephemeral","box-socket","iqfeed","box","code","foo","web-rep","poker-fold"]

#+begin_src haskell :results output
sequence_ (zipWith (\n bs -> BS.writeFile ("/Users/tonyday/haskell/" <> n <> "/" <> n <> ".cabal") bs) ns (snd <$> cs))
#+end_src

#+RESULTS:

* writing licenses

#+begin_src haskell :results output
ps <- allCabalProjects "/Users/tonyday/haskell"
#+end_src

#+RESULTS:

#+begin_src haskell :results output
ps
#+end_src

#+RESULTS:
: ["numhask","mealy","box","formatn","prettychart","cabal-fix","code","poker-fold","numhask-space","iqfeed","box-socket","numhask-array","tonyday567","foo","web-rep","baz","dotparse","perf","anal","research-hackage","chart-svg","ephemeral"]

#+begin_src haskell :results output
sequence_ $ fromMaybe (pure ()) . (\p -> BS.writeFile ("/Users/tonyday/haskell/" <> p <> "/" <> "LICENSE") . C.pack . licenseFile "Tony Day" . show <$> (Map.lookup p (Map.fromList yearList))) <$> ps
#+end_src

#+RESULTS:

* categories

#+begin_src haskell :results output
myCats = first (takeWhile (/='.')) . second ((maybe "" (\(Field _ ((FieldLine _ c:_))) -> c)) . listToMaybe . filter (hasName ["category"]) . toFields) <$> cs
#+end_src

#+RESULTS:

#+begin_src haskell :results output
myCats
#+end_src

#+RESULTS:
: [("tonyday567","project"),("research-hackage","project"),("anal","project"),("numhask-array","project"),("chart-svg","charts"),("cabal-fix","project"),("numhask-space","mathematics"),("mealy","folding"),("formatn","Development"),("prettychart","project"),("dotparse","project"),("perf","project"),("numhask","mathematics"),("ephemeral","project"),("box-socket","project"),("iqfeed","API"),("box","project"),("code","project"),("foo",""),("web-rep","web"),("poker-fold","project")]

#+begin_src haskell :results output
import Data.Ord
take 100 $ List.sortOn (Down . snd) cats
#+end_src

#+RESULTS:
: [("Data",2427),("Web",1990),("Network",1122),("Text",1029),("Development",861),("Control",818),("SYstem",785),("Language",769),("Math",724),("Graphics",629),("Database",539),("Unclassified",487),("Testing",435),("AWS",384),("Data Structures",325),("Game",296),("Parsing",257),("Concurrency",250),("Cloud",227),("Sound",216),("Codec",190),("Google",188),("Cryptography",175),("Distribution",153),("Compilers/Interpreters",147),("FFI",139),("Generics",135),("Algorithms",134),("Bioinformatics",129),("XML",116),("Foreign",114),("JSON",114),("Utils",113),("FRP",109),("Music",106),("Yesod",104),("Console",96),("Prelude",96),("Monads",92),("Natural Language Processing",92),("User Interfaces",92),("Finance",81),("GUI",81),("Numeric",81),("AI",79),("Conduit",76),("Compiler",72),("Numerical",72),("Machine Learning",69),("Hardware",68),("Statistics",66),("Utility",66),("Configuration",65),("Time",65),("Bindings",64),("Servant",64),("Distributed Computing",62),("Logging",62),("Streaming",61),("Algebra",58),("Library",58),("Lenses",56),("Pipes",56),("ACME",55),("Dependent Types",55),("Tools",53),("Theorem Provers",52),("CLI",50),("Debug",48),("Template Haskell",46),("Graphs",44),("Test",44),("Formal Methods",43),("Security",43),("Type System",42),("Game Engine",41),("Logic",41),("API",40),("Reactivity",39),("Filesystem",38),("Parallelism",38),("Records",38),("JavaScript",35),("Nix",35),("Physics",35),("Snap",35),("Application",34),("Compression",33),("Education",33),("Embedded",33),("Enumerator",33),("GHC",33),("Serialization",31),("Code Generation",30),("Crypto",30),("PostgreSQL",30),("Data Mining",28),("Other",28),("Parser",28),("Accelerate",27)]

RESULTS:
#+begin_example
[
    ( "Data"
    , 2427
    )
,
    ( "Web"
    , 1990
    )
,
    ( "Network"
    , 1122
    )
,
    ( "Text"
    , 1029
    )
,
    ( "Development"
    , 861
    )
,
    ( "Control"
    , 818
    )
,
    ( "SYstem"
    , 785
    )
,
    ( "Language"
    , 769
    )
,
    ( "Math"
    , 724
    )
,
    ( "Graphics"
    , 629
    )
,
    ( "Database"
    , 539
    )
,
    ( "Unclassified"
    , 487
    )
,
    ( "Testing"
    , 435
    )
,
    ( "AWS"
    , 384
    )
,
    ( "Data Structures"
    , 325
    )
,
    ( "Game"
    , 296
    )
,
    ( "Parsing"
    , 257
    )
,
    ( "Concurrency"
    , 250
    )
,
    ( "Cloud"
    , 227
    )
,
    ( "Sound"
    , 216
    )
,
    ( "Codec"
    , 190
    )
,
    ( "Google"
    , 188
    )
,
    ( "Cryptography"
    , 175
    )
,
    ( "Distribution"
    , 153
    )
,
    ( "Compilers/Interpreters"
    , 147
    )
,
    ( "FFI"
    , 139
    )
,
    ( "Generics"
    , 135
    )
,
    ( "Algorithms"
    , 134
    )
,
    ( "Bioinformatics"
    , 129
    )
,
    ( "XML"
    , 116
    )
,
    ( "Foreign"
    , 114
    )
,
    ( "JSON"
    , 114
    )
,
    ( "Utils"
    , 113
    )
,
    ( "FRP"
    , 109
    )
,
    ( "Music"
    , 106
    )
,
    ( "Yesod"
    , 104
    )
,
    ( "Console"
    , 96
    )
,
    ( "Prelude"
    , 96
    )
,
    ( "Monads"
    , 92
    )
,
    ( "Natural Language Processing"
    , 92
    )
,
    ( "User Interfaces"
    , 92
    )
,
    ( "Finance"
    , 81
    )
,
    ( "GUI"
    , 81
    )
,
    ( "Numeric"
    , 81
    )
,
    ( "AI"
    , 79
    )
,
    ( "Conduit"
    , 76
    )
,
    ( "Compiler"
    , 72
    )
,
    ( "Numerical"
    , 72
    )
,
    ( "Machine Learning"
    , 69
    )
,
    ( "Hardware"
    , 68
    )
]
#+end_example

* manual over-writes

#+begin_src haskell :results output
cfg = defaultRenderConfig {replaceCategory = True, replaceCopyright = True}
#+end_src

#+RESULTS:

#+begin_src haskell :results output
void $ mapM (\(fp,bs) -> BS.writeFile ("/Users/tonyday/haskell/cabal-fix/test/rendered/" <> fp) bs) (second (rerenderCabal cfg) <$> cs)
#+end_src

#+RESULTS:

* individual directory cabal

#+begin_src haskell :results output
fp = "/Users/tonyday/haskell/eulerproject/eulerproject.cabal"
cfg = defaultRenderConfig
rerenderFile fp cfg
#+end_src

#+RESULTS:



* cabal-fix.hs development

#+begin_src haskell :results output
d <- getCurrentDirectory
fp = takeBaseName d <> ".cabal"
bs <- getCabal fp
bs' = rerenderCabal defaultRenderConfig bs
ansiWlEditExpr <$> patch bs bs'
#+end_src

#+RESULTS:
#+begin_example
Just BS.concat
  [
    +"        , Diff\n",
    +"        , filepath\n",
    +"        , markup-parse\n",
    -"        , markup-parse\n",
    -"        , Diff\n",
    -"        , tree-diff\n",
    -"        , filepath\n",
    +"        , tree-diff          >=0.3 && <0.4\n",
    -"        , markup-parse\n",
    +"        , cabal-fix\n",
    -"        , cabal-fix\n",
    +"        , markup-parse\n"]
#+end_example


#+begin_src haskell :results output
rerenderFile fp cfg
#+end_src

#+RESULTS:
#+begin_example
Just BS.concat
  [
    +"        , Diff\n",
    +"        , filepath\n",
    +"        , markup-parse\n",
    -"        , markup-parse\n",
    -"        , Diff\n",
    -"        , tree-diff\n",
    -"        , filepath\n",
    +"        , tree-diff          >=0.3 && <0.4\n",
    -"        , markup-parse\n",
    +"        , cabal-fix\n",
    -"        , cabal-fix\n",
    +"        , markup-parse\n"]
#+end_example

  #+begin_src haskell :results output
import Data.TreeDiff
fp = "/Users/tonyday/haskell/perf/perf.cabal"
bs <- getCabal fp
  #+end_src

#+RESULTS:

#+begin_src haskell :results output
bs' = rerenderCabal defaultRenderConfig bs
#+end_src

#+RESULTS:

#+begin_src haskell :results output
ansiWlEditExpr <$> patch bs bs'
#+end_src

#+RESULTS:
: Nothing
